@module "helper"

@use "string" as string

pub const Range -> struct {
  lo: int,
  hi: int,
};

pub const Bounds -> struct {
  lo: int,
  hi: int,
};

pub const in_range -> fn (x: int, ranges: *Range, count: int) int {
  loop [i: int = 0](i < count) : (++i) {
    if (x >= ranges[i].lo && x <= ranges[i].hi) return 1;
  }
  return 0;
}

pub const num_digits -> fn (x: int) int {
  let d: int = 0;
  let temp: int = x;
  loop (temp != 0) : (++d) { temp = temp / 10; }
  return d;
}

pub const pow10 -> fn (exp: int) int {
    let result: int = 1;
    let base: int = 10;

    loop [e: int = exp](e > 0) : (e = e >> 1) {
        if ((e & 1) != 0) result = result * base;
        base = base * base;
    }

    return result;
}

pub const parse_ranges -> fn (pattern: *byte, ranges: *Range) int {
  let count: int = 0;

  loop [i: int = 0](pattern[i] != '\0') {
    loop (pattern[i] == ',' || pattern[i] == ' ' || pattern[i] == '\n') { ++i; }

    // parse left number
    let a: int = 0;
    loop (pattern[i] >= '0' && pattern[i] <= '9') : (++i) {
      a = a * 10 + (cast<int>(pattern[i]) - cast<int>('0'));
    }

    if (pattern[i] == '-') ++i;

    // parse right number
    let b: int = 0;
    loop (pattern[i] >= '0' && pattern[i] <= '9') : (++i) {
        b = b * 10 + (cast<int>(pattern[i]) - cast<int>('0'));
    }

    ranges[count] = Range{ lo: a, hi: b };
    ++count;

    if (pattern[i] == ',') ++i;
  }

  return count;
}

pub const get_global_bounds -> fn (ranges: *Range, count: int) Bounds {
    let global_lo: int = ranges[0].lo;
    let global_hi: int = ranges[0].hi;

    loop [i: int = 1](i < count) : (++i) {
      if (ranges[i].lo < global_lo) global_lo = ranges[i].lo;
      if (ranges[i].hi > global_hi) global_hi = ranges[i].hi;
    }

    return Bounds{ lo: global_lo, hi: global_hi };
}

pub const repeat_pattern -> fn (pattern: int, reps: int) int {
  let multiplier: int = pow10(num_digits(pattern));
  
  let result: int = 0;
  loop [i: int = 0](i < reps) : (++i) {
    result = result * multiplier + pattern;
  }
  return result;
}

pub const has_smaller_pattern -> fn (num: int, current_pattern_len: int) int {
  let digits: int = num_digits(num);
  
  loop [smaller_len: int = 1](smaller_len < current_pattern_len) : (++smaller_len) {
    if (digits % smaller_len != 0) continue;
    
    let divisor: int = pow10(smaller_len);
    let first_segment: int = num % divisor;
    let temp: int = num;
    let all_match: int = 1;
    
    let reps: int = digits / smaller_len;
    loop [i: int = 0](i < reps) : (++i) {
      let segment: int = temp % divisor;
      if (segment != first_segment) {
        all_match = 0;
        break;
      }
      temp = temp / divisor;
    }
    
    if (all_match == 1) return 1;
  }
  
  return 0;
}

pub const count_double_patterns -> fn (
  min_digits: int, 
  max_digits: int, 
  global_hi: int,
  ranges: *Range, 
  count: int
) int {
  let total: int = 0;
  
  loop [len: int = min_digits](len <= max_digits) : (++len) {
    if (len % 2 != 0) continue;

    let half: int = len / 2;
    let start: int = pow10(half - 1);
    let end: int = pow10(half) - 1;

    loop [s: int = start](s <= end) : (++s) {
      let num: int = repeat_pattern(s, 2);
      if (num > global_hi) break;

      if (in_range(num, ranges, count) == 1) {
        total = total + num;
      }
    }
  }
  
  return total;
}

pub const count_all_patterns -> fn (
  min_digits: int,
  max_digits: int,
  bounds: Bounds,
  ranges: *Range,
  count: int
) int {
  let total: int = 0;
  
  loop [total_len: int = min_digits](total_len <= max_digits) : (++total_len) {
    loop [pattern_len: int = 1](pattern_len <= total_len / 2) : (++pattern_len) {
      if (total_len % pattern_len != 0) continue;
      
      let reps: int = total_len / pattern_len;
      let pattern_start: int = pow10(pattern_len - 1);
      let pattern_end: int = pow10(pattern_len) - 1;
      
      loop [p: int = pattern_start](p <= pattern_end) : (++p) {
        let num: int = repeat_pattern(p, reps);
        
        if (num < bounds.lo) continue;
        if (num > bounds.hi) break;
        
        if (has_smaller_pattern(num, pattern_len) == 1) continue;
        
        if (in_range(num, ranges, count) == 1) {
          total = total + num;
        }
      }
    }
  }
  
  return total;
}
