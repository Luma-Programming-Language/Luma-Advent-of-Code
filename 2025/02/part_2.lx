@module "main"

@use "string" as string
@use "time" as time
@use "io" as io

const Range -> struct {
  lo: int,
  hi: int,
};

const in_range -> fn (x: int, ranges: *Range, count: int) int {
  loop [i: int = 0](i < count) : (++i) {
    if (x >= ranges[i].lo && x <= ranges[i].hi) return 1;
  }
  return 0;
}

const num_digits -> fn (x: int) int {
  let d: int = 0;
  let temp: int = x;
  loop (temp != 0) : (++d) { temp = temp / 10; }
  return d;
}

const parse_ranges -> fn (pattern: *byte, ranges: *Range) int {
  let count: int = 0;

  loop [i: int = 0](pattern[i] != '\0') {
    loop (pattern[i] == ',' || pattern[i] == ' ' || pattern[i] == '\n') { ++i; }

    // parse left number
    let a: int = 0;
    loop (pattern[i] >= '0' && pattern[i] <= '9') : (++i) {
      a = a * 10 + (cast<int>(pattern[i]) - cast<int>('0'));
    }

    if (pattern[i] == '-') ++i;

    // parse right number
    let b: int = 0;
    loop (pattern[i] >= '0' && pattern[i] <= '9') : (++i) {
        b = b * 10 + (cast<int>(pattern[i]) - cast<int>('0'));
    }

    ranges[count] = Range{ lo: a, hi: b };
    ++count;

    if (pattern[i] == ',') ++i;
  }

  return count;
}

// Generate a number by repeating pattern 'reps' times
const repeat_pattern -> fn (pattern: int, reps: int) int {
  let pattern_digits: int = num_digits(pattern);
  let multiplier: int = 1;
  loop [i: int = 0](i < pattern_digits) : (++i) {
    multiplier = multiplier * 10;
  }
  
  let result: int = 0;
  loop [i: int = 0](i < reps) : (++i) {
    result = result * multiplier + pattern;
  }
  return result;
}

// Check if a number can be formed by a smaller pattern length
const has_smaller_pattern -> fn (num: int, current_pattern_len: int) int {
  let digits: int = num_digits(num);
  
  loop [smaller_len: int = 1](smaller_len < current_pattern_len) : (++smaller_len) {
    if (digits % smaller_len != 0) continue;
    
    let reps: int = digits / smaller_len;
    let divisor: int = 1;
    loop [i: int = 0](i < smaller_len) : (++i) {
      divisor = divisor * 10;
    }
    
    let first_segment: int = num % divisor;
    let temp: int = num;
    let all_match: int = 1;
    
    loop [i: int = 0](i < reps) : (++i) {
      let segment: int = temp % divisor;
      if (segment != first_segment) {
        all_match = 0;
        break;
      }
      temp = temp / divisor;
    }
    
    if (all_match == 1) return 1;
  }
  
  return 0;
}

pub const main -> fn () int { 
  let speed: Timer = time::timer_start();

  let pattern: *byte = io::read_file("input.txt");
  let ranges: *Range = cast<*Range>(alloc(1000 * sizeof<Range>));
  defer { free(pattern); free(ranges); }

  let count: int = parse_ranges(pattern, ranges);

  let global_lo: int = ranges[0].lo;
  let global_hi: int = ranges[0].hi;

  loop [i: int = 1](i < count) : (++i) {
    if (ranges[i].lo < global_lo) global_lo = ranges[i].lo;
    if (ranges[i].hi > global_hi) global_hi = ranges[i].hi;
  }

  let min_digits: int = num_digits(global_lo);
  let max_digits: int = num_digits(global_hi);

  // Part 2: patterns repeated at least twice (any length)
  let part2_total: int = 0;
  loop [total_len: int = min_digits](total_len <= max_digits) : (++total_len) {
    // Try all possible pattern lengths
    loop [pattern_len: int = 1](pattern_len <= total_len / 2) : (++pattern_len) {
      if (total_len % pattern_len != 0) continue;
      
      let reps: int = total_len / pattern_len;
      
      // Generate all patterns of this length
      let pattern_start: int = 1;
      loop [i: int = 1](i < pattern_len) : (++i) {
        pattern_start = pattern_start * 10;
      }
      
      let pattern_end: int = pattern_start * 10 - 1;
      
      loop [p: int = pattern_start](p <= pattern_end) : (++p) {
        let num: int = repeat_pattern(p, reps);
        
        if (num < global_lo) continue;
        if (num > global_hi) break;
        
        // Only count if this is the smallest pattern that generates this number
        if (has_smaller_pattern(num, pattern_len) == 1) continue;
        
        if (in_range(num, ranges, count) == 1) {
          part2_total = part2_total + num;
        }
      }
    }
  }

  io::print_int("Part 2: %d; Took %dms\n", [part2_total, time::timer_elapsed_ms(speed)]);

  return 0; 
}