@module "main"

@use "string" as string
@use "io" as io

const find_max_voltage -> fn (voltages: *byte, len: int) int {
  let max_joltage: int = 0;

  loop [i: int = 0](i < len) : (++i) {
    if (voltages[i] < '0' || voltages[i] > '9') continue;

    loop [j: int = i + 1](j < len) : (++j) {
      if (voltages[j] < '0' || voltages[j] > '9') continue;
      
      let joltage: int = (cast<int>(voltages[i]) - 48) * 10 + (cast<int>(voltages[j]) - 48);
      if (joltage > max_joltage) max_joltage = joltage;
    }
  }

  return max_joltage;
}

#returns_ownership
const find_max_voltage_12 -> fn (voltages: *byte, len: int) *byte {
  let digit_count: int = 0;

  loop [i: int = 0](i < len) : (++i) {
    if (voltages[i] >= '0' && voltages[i] <= '9') digit_count++;
  }

  if (digit_count < 12) return cast<*byte>(0);

  let result: *byte = cast<*byte>(alloc(13));
  let result_index: int = 0;
  let start_pos: int = 0;

  loop [selected: int = 0](selected < 12) : (++selected) {
    let remaining_needed: int = 12 - selected - 1;
    let max_digit: int = -1;
    let max_pos: int = -1;

    loop [i: int = start_pos](i < len) : (++i) {
      if (voltages[i] < '0' || voltages[i] > '9') continue;

      // Count remaining digits after position i
      let remaining_after: int = 0;
      loop [j: int = i + 1](j < len) : (++j) {
        if (voltages[j] >= '0' && voltages[j] <= '9') 
          remaining_after++; 
      }

      if (remaining_after >= remaining_needed) {
        let digit: int = cast<int>(voltages[i]) - 48;
        if (digit > max_digit) {
          max_digit = digit;
          max_pos = i;
        }
      }
    }

    result[result_index++] = cast<byte>(max_digit + 48);
    start_pos = max_pos + 1;
  }
  
  result[12] = '\0';  // Null terminate
  return result;
}

const part_1 -> fn (usr_input: *byte) int {
  let total_joltage: int = 0;
  let line_start: int = 0;
  let i: int = 0;
  
  loop (usr_input[i] != '\0') : (++i) {
    if (usr_input[i] == '\n') {
      // Found end of line, process this line
      let line_len: int = i - line_start;
      if (line_len > 0) {
        let new_user_input: *byte = cast<*byte>(cast<int>(usr_input) + line_start);
        let max: int = find_max_voltage(new_user_input, line_len);
        total_joltage = total_joltage + max;
      }
      line_start = i + 1;
    }
  }
  
  if (i > line_start) {
    let new_user_input: *byte = cast<*byte>(cast<int>(usr_input) + line_start);
    let max: int = find_max_voltage(new_user_input, i - line_start);
    total_joltage = total_joltage + max;
  }

  return total_joltage;
}

const process_line -> fn (line: *byte, len: int, total: *byte) *byte {
  if (len <= 0) return total;
  
  let max_12: *byte = find_max_voltage_12(line, len);
  let old_total: *byte = total;
  defer { free(old_total); free(max_12); }

  total = string::string_add(total, max_12);

  return total;
}

#returns_ownership 
const part_2 -> fn (usr_input: *byte) *byte {
  let line_start: int = 0;
  let i: int = 0;
  let total: *byte = cast<*byte>(alloc(2));
  total[0] = '0';
  total[1] = '\0';
  
  loop (usr_input[i] != '\0') : (++i) {
    if (usr_input[i] == '\n') {
      let line: *byte = cast<*byte>(cast<int>(usr_input) + line_start);
      total = process_line(line, i - line_start, total);
      line_start = i + 1;
    }
  }
  
  // Handle last line
  let line: *byte = cast<*byte>(cast<int>(usr_input) + line_start);
  total = process_line(line, i - line_start, total);
  
  return total;
}

pub const main -> fn () int {  
  let usr_input: *byte = io::read_file("input.txt");
  defer { free(usr_input); }
  
  io::print_int("Total joltage (Part 1): %d\n", [part_1(usr_input)]);
  
  let part2_result: *byte = part_2(usr_input);
  io::print_str("Total 12-digit joltage (Part 2): %s\n", [part2_result]);
  free(part2_result);

  return 0; 
}
